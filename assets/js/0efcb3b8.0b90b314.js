"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[7633],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>u});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=l(t),u=a,h=p["".concat(c,".").concat(u)]||p[u]||d[u]||i;return t?r.createElement(h,o(o({ref:n},m),{},{components:t})):r.createElement(h,o({ref:n},m))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},93618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(87462),a=(t(67294),t(3905));const i={},o="Governance schema and contract",s={unversionedId:"learn/governance-schema-and-contract",id:"learn/governance-schema-and-contract",title:"Governance schema and contract",description:"Governances in Taple are special subjects. Governances have a specific schema and contract defined within the TAPLE code. This is the case because prior configuration is necessary. This schema and contract must be the same for all participants in a network, otherwise failures can occur because a different result is expected, or the schema is valid for one participant but not for another. This schema and contract do not appear explicitly in the governance itself, but are within Taple and cannot be modified.",source:"@site/docs/learn/governance-schema-and-contract.md",sourceDirName:"learn",slug:"/learn/governance-schema-and-contract",permalink:"/docs/next/learn/governance-schema-and-contract",draft:!1,tags:[],version:"current",lastUpdatedAt:1697193786,formattedLastUpdatedAt:"Oct 13, 2023",frontMatter:{},sidebar:"learnSidebar",previous:{title:"Governance structure",permalink:"/docs/next/learn/governance-structure"},next:{title:"Other topics",permalink:"/docs/next/learn/other-topics"}},c={},l=[],m={toc:l};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"governance-schema-and-contract"},"Governance schema and contract"),(0,a.kt)("p",null,"Governances in Taple are special subjects. Governances have a specific schema and contract defined within the TAPLE code. This is the case because prior configuration is necessary. This schema and contract must be the same for all participants in a network, otherwise failures can occur because a different result is expected, or the schema is valid for one participant but not for another. This schema and contract do not appear explicitly in the governance itself, but are within Taple and cannot be modified."),(0,a.kt)("admonition",{title:"Governance Schema",type:"info"},(0,a.kt)("details",null,(0,a.kt)("summary",null,"Click to look at the full governance schema."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$defs": {\n    "role": {\n      "type": "string",\n      "enum": ["VALIDATOR", "CREATOR", "ISSUER", "WITNESS", "APPROVER", "EVALUATOR"]\n    },\n    "quorum": {\n      "oneOf": [\n        {\n          "type": "string",\n          "enum": ["MAJORITY"]\n        },\n        {\n          "type": "object",\n          "properties": {\n            "FIXED": {\n              "type": "number",\n              "minimum": 1,\n              "multipleOf": 1\n            }\n          },\n          "required": ["FIXED"],\n          "additionalProperties": false\n        },\n        {\n          "type": "object",\n          "properties": {\n            "PERCENTAGE": {\n              "type": "number",\n              "minimum": 0,\n              "maximum": 1\n            }\n          },\n          "required": ["PERCENTAGE"],\n          "additionalProperties": false\n        }\n      ]\n    }\n  },\n  "type": "object",\n  "additionalProperties": false,\n  "required": [\n    "members",\n    "schemas",\n    "policies",\n    "roles"\n  ],\n  "properties": {\n    "members": {\n      "type": "array",\n      "items": {\n        "type": "object",\n        "properties": {\n          "name": {\n            "type": "string"\n          },\n          "id": {\n            "type": "string",\n            "format": "keyidentifier"\n          }\n        },\n        "required": [\n          "id",\n          "name"\n        ],\n        "additionalProperties": false\n      }\n    },\n    "roles": {\n      "type": "array",\n      "items": {\n        "type": "object",\n        "properties": {\n          "who": {\n            "oneOf": [\n            {\n              "type": "object",\n              "properties": {\n                "ID": {\n                  "type": "string"\n                }\n              },\n              "required": ["ID"],\n              "additionalProperties": false\n            },\n            {\n              "type": "object",\n              "properties": {\n                "NAME": {\n                  "type": "string"\n                }\n              },\n              "required": ["NAME"],\n              "additionalProperties": false\n            },\n            {\n              "const": "MEMBERS"\n            },\n            {\n              "const": "ALL"\n            },\n            {\n              "const": "NOT_MEMBERS"\n            }\n          ]\n        },\n        "namespace": {\n          "type": "string"\n        },\n        "role": {\n          "$ref": "#/$defs/role"\n        },\n        "schema": {\n          "oneOf": [\n            {\n              "type": "object",\n              "properties": {\n                "ID": {\n                  "type": "string"\n                }\n              },\n              "required": ["ID"],\n              "additionalProperties": false\n            },\n            {\n              "const": "ALL"\n            },\n            {\n              "const": "NOT_GOVERNANCE"\n            }\n            ]\n          }\n        },\n        "required": ["who", "role", "schema", "namespace"],\n        "additionalProperties": false\n      }\n    },\n    "schemas": {\n      "type": "array",\n      "minItems": 0,\n      "items": {\n        "type": "object",\n        "properties": {\n          "id": {\n            "type": "string"\n          },\n          "schema": {\n            "$schema": "http://json-schema.org/draft/2020-12/schema",\n            "$id": "http://json-schema.org/draft/2020-12/schema",\n            "$vocabulary": {\n              "http://json-schema.org/draft/2020-12/vocab/core": true,\n              "http://json-schema.org/draft/2020-12/vocab/applicator": true,\n              "http://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n              "http://json-schema.org/draft/2020-12/vocab/validation": true,\n              "http://json-schema.org/draft/2020-12/vocab/meta-data": true,\n              "http://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n              "http://json-schema.org/draft/2020-12/vocab/content": true\n            },\n            "$dynamicAnchor": "meta",\n            "title": "Core and validation specifications meta-schema",\n            "allOf": [\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/core",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/core": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "Core vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "$id": {\n                    "$ref": "#/$defs/uriReferenceString",\n                    "$comment": "Non-empty fragments not allowed.",\n                    "pattern": "^[^#]*#?$"\n                  },\n                  "$schema": {\n                    "$ref": "#/$defs/uriString"\n                  },\n                  "$ref": {\n                    "$ref": "#/$defs/uriReferenceString"\n                  },\n                  "$anchor": {\n                    "$ref": "#/$defs/anchorString"\n                  },\n                  "$dynamicRef": {\n                    "$ref": "#/$defs/uriReferenceString"\n                  },\n                  "$dynamicAnchor": {\n                    "$ref": "#/$defs/anchorString"\n                  },\n                  "$vocabulary": {\n                    "type": "object",\n                    "propertynames": {\n                      "$ref": "#/$defs/uriString"\n                    },\n                    "additionalProperties": {\n                      "type": "boolean"\n                    }\n                  },\n                  "$comment": {\n                    "type": "string"\n                  },\n                  "$defs": {\n                    "type": "object",\n                    "additionalProperties": {\n                      "$dynamicRef": "#meta"\n                    }\n                  }\n                },\n                "$defs": {\n                  "anchorString": {\n                    "type": "string",\n                    "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n                  },\n                  "uriString": {\n                    "type": "string",\n                    "format": "uri"\n                  },\n                  "uriReferenceString": {\n                    "type": "string",\n                    "format": "uri-reference"\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/applicator": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "Applicator vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "prefixItems": {\n                    "$ref": "#/$defs/schemaArray"\n                  },\n                  "items": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "contains": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "additionalProperties": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "properties": {\n                    "type": "object",\n                    "additionalProperties": {\n                      "$dynamicRef": "#meta"\n                    },\n                    "default": {}\n                  },\n                  "patternProperties": {\n                    "type": "object",\n                    "additionalProperties": {\n                      "$dynamicRef": "#meta"\n                    },\n                    "propertynames": {\n                      "format": "regex"\n                    },\n                    "default": {}\n                  },\n                  "dependentschemas": {\n                    "type": "object",\n                    "additionalProperties": {\n                      "$dynamicRef": "#meta"\n                    },\n                    "default": {}\n                  },\n                  "propertynames": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "if": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "then": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "else": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "allOf": {\n                    "$ref": "#/$defs/schemaArray"\n                  },\n                  "anyOf": {\n                    "$ref": "#/$defs/schemaArray"\n                  },\n                  "oneOf": {\n                    "$ref": "#/$defs/schemaArray"\n                  },\n                  "not": {\n                    "$dynamicRef": "#meta"\n                  }\n                },\n                "$defs": {\n                  "schemaArray": {\n                    "type": "array",\n                    "minItems": 1,\n                    "items": {\n                      "$dynamicRef": "#meta"\n                    }\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "Unevaluated applicator vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "unevaluatedItems": {\n                    "$dynamicRef": "#meta"\n                  },\n                  "unevaluatedProperties": {\n                    "$dynamicRef": "#meta"\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/validation": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "validation vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "type": {\n                    "anyOf": [\n                      {\n                        "$ref": "#/$defs/simpleTypes"\n                      },\n                      {\n                        "type": "array",\n                        "items": {\n                          "$ref": "#/$defs/simpleTypes"\n                        },\n                        "minItems": 1,\n                        "uniqueItems": true\n                      }\n                    ]\n                  },\n                  "const": true,\n                  "enum": {\n                    "type": "array",\n                    "items": true\n                  },\n                  "multipleOf": {\n                    "type": "number",\n                    "exclusiveMinimum": 0\n                  },\n                  "maximum": {\n                    "type": "number"\n                  },\n                  "exclusiveMaximum": {\n                    "type": "number"\n                  },\n                  "minimum": {\n                    "type": "number"\n                  },\n                  "exclusiveMinimum": {\n                    "type": "number"\n                  },\n                  "maxLength": {\n                    "$ref": "#/$defs/nonNegativeInteger"\n                  },\n                  "minLength": {\n                    "$ref": "#/$defs/nonNegativeIntegerDefault0"\n                  },\n                  "pattern": {\n                    "type": "string",\n                    "format": "regex"\n                  },\n                  "maxItems": {\n                    "$ref": "#/$defs/nonNegativeInteger"\n                  },\n                  "minItems": {\n                    "$ref": "#/$defs/nonNegativeIntegerDefault0"\n                  },\n                  "uniqueItems": {\n                    "type": "boolean",\n                    "default": false\n                  },\n                  "maxContains": {\n                    "$ref": "#/$defs/nonNegativeInteger"\n                  },\n                  "minContains": {\n                    "$ref": "#/$defs/nonNegativeInteger",\n                    "default": 1\n                  },\n                  "maxProperties": {\n                    "$ref": "#/$defs/nonNegativeInteger"\n                  },\n                  "minProperties": {\n                    "$ref": "#/$defs/nonNegativeIntegerDefault0"\n                  },\n                  "required": {\n                    "$ref": "#/$defs/stringArray"\n                  },\n                  "dependentRequired": {\n                    "type": "object",\n                    "additionalProperties": {\n                      "$ref": "#/$defs/stringArray"\n                    }\n                  }\n                },\n                "$defs": {\n                  "nonNegativeInteger": {\n                    "type": "integer",\n                    "minimum": 0\n                  },\n                  "nonNegativeIntegerDefault0": {\n                    "$ref": "#/$defs/nonNegativeInteger",\n                    "default": 0\n                  },\n                  "simpleTypes": {\n                    "enum": [\n                      "array",\n                      "boolean",\n                      "integer",\n                      "null",\n                      "number",\n                      "object",\n                      "string"\n                    ]\n                  },\n                  "stringArray": {\n                    "type": "array",\n                    "items": {\n                      "type": "string"\n                    },\n                    "uniqueItems": true,\n                    "default": []\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "Meta-data vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "title": {\n                    "type": "string"\n                  },\n                  "description": {\n                    "type": "string"\n                  },\n                  "default": true,\n                  "deprecated": {\n                    "type": "boolean",\n                    "default": false\n                  },\n                  "readOnly": {\n                    "type": "boolean",\n                    "default": false\n                  },\n                  "writeOnly": {\n                    "type": "boolean",\n                    "default": false\n                  },\n                  "examples": {\n                    "type": "array",\n                    "items": true\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "Format vocabulary meta-schema for annotation results",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "format": {\n                    "type": "string"\n                  }\n                }\n              },\n              {\n                "$schema": "https://json-schema.org/draft/2020-12/schema",\n                "$id": "https://json-schema.org/draft/2020-12/meta/content",\n                "$vocabulary": {\n                  "https://json-schema.org/draft/2020-12/vocab/content": true\n                },\n                "$dynamicAnchor": "meta",\n                "title": "content vocabulary meta-schema",\n                "type": [\n                  "object",\n                  "boolean"\n                ],\n                "properties": {\n                  "contentEncoding": {\n                    "type": "string"\n                  },\n                  "contentMediaType": {\n                    "type": "string"\n                  },\n                  "contentschema": {\n                    "$dynamicRef": "#meta"\n                  }\n                }\n              }\n            ],\n            "type": [\n              "object",\n              "boolean"\n            ],\n            "$comment": "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.",\n            "properties": {\n              "definitions": {\n                "$comment": "\\"definitions\\" has been replaced by \\"$defs\\".",\n                "type": "object",\n                "additionalProperties": {\n                  "$dynamicRef": "#meta"\n                },\n                "deprecated": true,\n                "default": {}\n              },\n              "dependencies": {\n                "$comment": "\\"dependencies\\" has been split and replaced by \\"dependentschemas\\" and \\"dependentRequired\\" in order to serve their differing semantics.",\n                "type": "object",\n                "additionalProperties": {\n                  "anyOf": [\n                    {\n                      "$dynamicRef": "#meta"\n                    },\n                    {\n                      "$ref": "meta/validation#/$defs/stringArray"\n                    }\n                  ]\n                },\n                "deprecated": true,\n                "default": {}\n              },\n              "$recursiveAnchor": {\n                "$comment": "\\"$recursiveAnchor\\" has been replaced by \\"$dynamicAnchor\\".",\n                "$ref": "meta/core#/$defs/anchorString",\n                "deprecated": true\n              },\n              "$recursiveRef": {\n                "$comment": "\\"$recursiveRef\\" has been replaced by \\"$dynamicRef\\".",\n                "$ref": "meta/core#/$defs/uriReferenceString",\n                "deprecated": true\n              }\n            }\n          },\n          "initial_value": {},\n          "contract": {\n            "type": "object",\n            "properties": {\n              "raw": {\n                "type": "string"\n              },\n            },\n            "additionalProperties": false,\n            "required": ["raw"]\n          },\n        },\n        "required": [\n          "id",\n          "schema",\n          "initial_value",\n          "contract"\n        ],\n        "additionalProperties": false\n      }\n    },\n    "policies": {\n      "type": "array",\n      "items": {\n        "type": "object",\n        "additionalProperties": false,\n        "required": [\n          "id", "approve", "evaluate", "validate"\n        ],\n        "properties": {\n          "id": {\n            "type": "string"\n          },\n          "approve": {\n            "type": "object",\n            "additionalProperties": false,\n            "required": ["quorum"],\n            "properties": {\n              "quorum": {\n                "$ref": "#/$defs/quorum"\n              }\n            }\n          },\n          "evaluate": {\n            "type": "object",\n            "additionalProperties": false,\n            "required": ["quorum"],\n            "properties": {\n              "quorum": {\n                "$ref": "#/$defs/quorum"\n              }\n            }\n          },\n          "validate": {\n            "type": "object",\n            "additionalProperties": false,\n            "required": ["quorum"],\n            "properties": {\n              "quorum": {\n                "$ref": "#/$defs/quorum"\n              }\n            }\n          }\n        }\n      }\n    }        \n  }\n}\n')))),(0,a.kt)("p",null,"And its initial state is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "members": [],\n    "roles": [\n        {\n        "namespace": "",\n        "role": "WITNESS",\n        "schema": {\n            "ID": "governance"\n        },\n        "who": "MEMBERS"\n        }\n    ],\n    "schemas": [],\n    "policies": [\n        {\n        "id": "governance",\n        "approve": {\n            "quorum": "MAJORITY"\n        },\n        "evaluate": {\n            "quorum": "MAJORITY"\n        },\n        "validate": {\n            "quorum": "MAJORITY"\n        }\n        }\n    ]\n}\n')),(0,a.kt)("p",null,"Essentially, the initial state of the governance defines that all members added to the governance will be witnesses, and a majority of signatures from all members is required for any of the phases in the lifecycle of governance change events. However, it does not have any additional schemas, which will need to be added according to the needs of the use cases."),(0,a.kt)("p",null,"The governance contract is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="Governance Contract"',title:'"Governance','Contract"':!0},'mod sdk;\nuse std::collections::HashSet;\nuse thiserror::Error;\nuse sdk::ValueWrapper;\nuse serde::{de::Visitor, ser::SerializeMap, Deserialize, Serialize};\n\n#[derive(Clone)]\n#[allow(non_snake_case)]\n#[allow(non_camel_case_types)]\npub enum Who {\n    ID { ID: String },\n    NAME { NAME: String },\n    MEMBERS,\n    ALL,\n    NOT_MEMBERS,\n}\n\nimpl Serialize for Who {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        match self {\n            Who::ID { ID } => {\n                let mut map = serializer.serialize_map(Some(1))?;\n                map.serialize_entry("ID", ID)?;\n                map.end()\n            }\n            Who::NAME { NAME } => {\n                let mut map = serializer.serialize_map(Some(1))?;\n                map.serialize_entry("NAME", NAME)?;\n                map.end()\n            }\n            Who::MEMBERS => serializer.serialize_str("MEMBERS"),\n            Who::ALL => serializer.serialize_str("ALL"),\n            Who::NOT_MEMBERS => serializer.serialize_str("NOT_MEMBERS"),\n        }\n    }\n}\n\nimpl<\'de> Deserialize<\'de> for Who {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<\'de>,\n    {\n        struct WhoVisitor;\n        impl<\'de> Visitor<\'de> for WhoVisitor {\n            type Value = Who;\n            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n                formatter.write_str("Who")\n            }\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::MapAccess<\'de>,\n            {\n                // They should only have one entry\n                let Some(key) = map.next_key::<String>()? else {\n                    return Err(serde::de::Error::missing_field("ID or NAME"))\n                };\n                let result = match key.as_str() {\n                    "ID" => {\n                        let id: String = map.next_value()?;\n                        Who::ID { ID: id }\n                    }\n                    "NAME" => {\n                        let name: String = map.next_value()?;\n                        Who::NAME { NAME: name }\n                    }\n                    _ => return Err(serde::de::Error::unknown_field(&key, &["ID", "NAME"])),\n                };\n                let None = map.next_key::<String>()? else {\n                    return Err(serde::de::Error::custom("Input data is not valid. The data contains unkown entries"));\n                };\n                Ok(result)\n            }\n            fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                match v.as_str() {\n                    "MEMBERS" => Ok(Who::MEMBERS),\n                    "ALL" => Ok(Who::ALL),\n                    "NOT_MEMBERS" => Ok(Who::NOT_MEMBERS),\n                    other => Err(serde::de::Error::unknown_variant(\n                        other,\n                        &["MEMBERS", "ALL", "NOT_MEMBERS"],\n                    )),\n                }\n            }\n            fn visit_borrowed_str<E>(self, v: &\'de str) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                match v {\n                    "MEMBERS" => Ok(Who::MEMBERS),\n                    "ALL" => Ok(Who::ALL),\n                    "NOT_MEMBERS" => Ok(Who::NOT_MEMBERS),\n                    other => Err(serde::de::Error::unknown_variant(\n                        other,\n                        &["MEMBERS", "ALL", "NOT_MEMBERS"],\n                    )),\n                }\n            }\n        }\n        deserializer.deserialize_any(WhoVisitor {})\n    }\n}\n\n#[derive(Clone)]\n#[allow(non_snake_case)]\n#[allow(non_camel_case_types)]\npub enum SchemaEnum {\n    ID { ID: String },\n    NOT_GOVERNANCE,\n    ALL,\n}\n\nimpl Serialize for SchemaEnum {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        match self {\n            SchemaEnum::ID { ID } => {\n                let mut map = serializer.serialize_map(Some(1))?;\n                map.serialize_entry("ID", ID)?;\n                map.end()\n            }\n            SchemaEnum::NOT_GOVERNANCE => serializer.serialize_str("NOT_GOVERNANCE"),\n            SchemaEnum::ALL => serializer.serialize_str("ALL"),\n        }\n    }\n}\n\nimpl<\'de> Deserialize<\'de> for SchemaEnum {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: serde::Deserializer<\'de>,\n    {\n        struct SchemaEnumVisitor;\n        impl<\'de> Visitor<\'de> for SchemaEnumVisitor {\n            type Value = SchemaEnum;\n            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n                formatter.write_str("Schema")\n            }\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: serde::de::MapAccess<\'de>,\n            {\n                // They should only have one entry\n                let Some(key) = map.next_key::<String>()? else {\n                    return Err(serde::de::Error::missing_field("ID"))\n                };\n                let result = match key.as_str() {\n                    "ID" => {\n                        let id: String = map.next_value()?;\n                        SchemaEnum::ID { ID: id }\n                    }\n                    _ => return Err(serde::de::Error::unknown_field(&key, &["ID", "NAME"])),\n                };\n                let None = map.next_key::<String>()? else {\n                    return Err(serde::de::Error::custom("Input data is not valid. The data contains unkown entries"));\n                };\n                Ok(result)\n            }\n            fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                match v.as_str() {\n                    "ALL" => Ok(Self::Value::ALL),\n                    "NOT_GOVERNANCE" => Ok(Self::Value::NOT_GOVERNANCE),\n                    other => Err(serde::de::Error::unknown_variant(\n                        other,\n                        &["ALL", "NOT_GOVERNANCE"],\n                    )),\n                }\n            }\n            fn visit_borrowed_str<E>(self, v: &\'de str) -> Result<Self::Value, E>\n            where\n                E: serde::de::Error,\n            {\n                match v {\n                    "ALL" => Ok(Self::Value::ALL),\n                    "NOT_GOVERNANCE" => Ok(Self::Value::NOT_GOVERNANCE),\n                    other => Err(serde::de::Error::unknown_variant(\n                        other,\n                        &["ALL", "NOT_GOVERNANCE"],\n                    )),\n                }\n            }\n        }\n        deserializer.deserialize_any(SchemaEnumVisitor {})\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Role {\n    who: Who,\n    namespace: String,\n    role: RoleEnum,\n    schema: SchemaEnum,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub enum RoleEnum {\n    VALIDATOR,\n    CREATOR,\n    ISSUER,\n    WITNESS,\n    APPROVER,\n    EVALUATOR,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Member {\n    id: String,\n    name: String,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Contract {\n    raw: String,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\n#[allow(non_snake_case)]\n#[allow(non_camel_case_types)]\npub enum Quorum {\n    MAJORITY,\n    FIXED(u64),\n    PERCENTAGE(f64),\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Validation {\n    quorum: Quorum,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Policy {\n    id: String,\n    approve: Validation,\n    evaluate: Validation,\n    validate: Validation,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Schema {\n    id: String,\n    schema: serde_json::Value,\n    initial_value: serde_json::Value,\n    contract: Contract,\n}\n\n#[repr(C)]\n#[derive(Serialize, Deserialize, Clone)]\npub struct Governance {\n    members: Vec<Member>,\n    roles: Vec<Role>,\n    schemas: Vec<Schema>,\n    policies: Vec<Policy>,\n}\n\n// Define "Event family".\n#[derive(Serialize, Deserialize, Debug)]\npub enum GovernanceEvent {\n    Patch { data: ValueWrapper },\n}\n\n#[no_mangle]\npub unsafe fn main_function(state_ptr: i32, event_ptr: i32, is_owner: i32) -> u32 {\n    sdk::execute_contract(state_ptr, event_ptr, is_owner, contract_logic)\n}\n\n// Contract logic with expected data types\n// Returns the pointer to the data written with the modified state.\nfn contract_logic(\n    context: &sdk::Context<Governance, GovernanceEvent>,\n    contract_result: &mut sdk::ContractResult<Governance>,\n) {\n    // It would be possible to add error handling\n    // It could be interesting to do the operations directly as serde_json:Value instead of "Custom Data".\n    let state = &mut contract_result.final_state;\n    let _is_owner = &context.is_owner;\n    match &context.event {\n        GovernanceEvent::Patch { data } => {\n            // A JSON PATCH is received\n            // It is applied directly to the state\n            let patched_state = sdk::apply_patch(data.0.clone(), &context.initial_state).unwrap();\n            if let Ok(_) = check_governance_state(&patched_state) {\n                *state = patched_state;\n                contract_result.success = true;\n                contract_result.approval_required = true;\n            } else {\n                contract_result.success = false;\n            }\n        }\n    }\n}\n\n#[derive(Error, Debug)]\nenum StateError {\n    #[error("A member\'s name is duplicated")]\n    DuplicatedMemberName,\n    #[error("A member\'s ID is duplicated")]\n    DuplicatedMemberID,\n    #[error("A policy identifier is duplicated")]\n    DuplicatedPolicyID,\n    #[error("No governace policy detected")]\n    NoGvernancePolicy,\n    #[error("It is not allowed to specify a different schema for the governnace")]\n    GovernanceShchemaIDDetected,\n    #[error("Schema ID is does not have a policy")]\n    NoCorrelationSchemaPolicy,\n    #[error("There are policies not correlated to any schema")]\n    PoliciesWithoutSchema,\n}\n\nfn check_governance_state(state: &Governance) -> Result<(), StateError> {\n    // We must check several aspects of the status.\n    // There cannot be duplicate members, either in name or ID.\n    check_members(&state.members)?;\n    // There can be no duplicate policies and the one associated with the governance itself must be present.\n    let policies_names = check_policies(&state.policies)?;\n    // Schema policies that do not exist cannot be indicated. Likewise, there cannot be\n    // schemas without policies. The correlation must be one-to-one\n    check_schemas(&state.schemas, policies_names)\n}\n\nfn check_members(members: &Vec<Member>) -> Result<(), StateError> {\n    let mut name_set = HashSet::new();\n    let mut id_set = HashSet::new();\n    for member in members {\n        if name_set.contains(&member.name) {\n            return Err(StateError::DuplicatedMemberName);\n        }\n        name_set.insert(&member.name);\n        if id_set.contains(&member.id) {\n            return Err(StateError::DuplicatedMemberID);\n        }\n        id_set.insert(&member.id);\n    }\n    Ok(())\n}\n\nfn check_policies(policies: &Vec<Policy>) -> Result<HashSet<String>, StateError> {\n    // Check that there are no duplicate policies and that the governance policy is included.\n    let mut is_governance_present = false;\n    let mut id_set = HashSet::new();\n    for policy in policies {\n        if id_set.contains(&policy.id) {\n            return Err(StateError::DuplicatedPolicyID);\n        }\n        id_set.insert(&policy.id);\n        if &policy.id == "governance" {\n            is_governance_present = true\n        }\n    }\n    if !is_governance_present {\n        return Err(StateError::NoGvernancePolicy);\n    }\n    id_set.remove(&String::from("governance"));\n    Ok(id_set.into_iter().cloned().collect())\n}\n\nfn check_schemas(\n    schemas: &Vec<Schema>,\n    mut policies_names: HashSet<String>,\n) -> Result<(), StateError> {\n    // We check that there are no duplicate schemas.\n    // We also have to check that the initial states are valid according to the json_schema\n    // Also, there cannot be a schema with id "governance".\n    for schema in schemas {\n        if &schema.id == "governance" {\n            return Err(StateError::GovernanceShchemaIDDetected);\n        }\n        // There can be no duplicates and they must be matched with policies_names\n        if !policies_names.remove(&schema.id) {\n            // Not related to policies_names\n            return Err(StateError::NoCorrelationSchemaPolicy);\n        }\n    }\n    if !policies_names.is_empty() {\n        return Err(StateError::PoliciesWithoutSchema);\n    }\n    Ok(())\n}\n')),(0,a.kt)("p",null,'The governance contract is currently designed to only support one method/event - the "Patch". This method allows us to send changes to the governance in the form of JSON-Patch, a standard format for expressing a sequence of operations to apply to a JavaScript Object Notation (JSON) document.'),(0,a.kt)("p",null,"For instance, if we have a default governance and we want to make a change, such as adding a member, we would first calculate the JSON-Patch to express this change. This can be done using any tool that follows the JSON Patch standard RFC 6902, or with the use of our own tool, ",(0,a.kt)("a",{parentName:"p",href:"/docs/next/learn/client-tools#taple-patch"},"taple-patch"),"."),(0,a.kt)("p",null,"This way, the governance contract leverages the flexibility of the JSON-Patch standard to allow for a wide variety of state changes while maintaining a simple and single method interface."),(0,a.kt)("p",null,"The contract has a close relationship with the schema, as it takes into account its definition to obtain the state before the execution of the contract and to validate it at the end of such execution."),(0,a.kt)("p",null,"Currently, it only has one function that can be called from an event of type ",(0,a.kt)("strong",{parentName:"p"},"Fact"),", the Patch method: ",(0,a.kt)("strong",{parentName:"p"},"Patch { data: ValueWrapper }"),". This method obtains a JSON patch that applies the changes it includes directly on the properties of the governance subject. At the end of its execution, it calls the function that checks that the final state obtained after applying the patch is a valid governance."))}d.isMDXComponent=!0}}]);